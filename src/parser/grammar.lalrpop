use ::ast;
use std::str::FromStr;

grammar;

pub Ident: ast::Ident
    = <s:r"[a-zA-Z_][a-zA-Z0-9_]*">
    => ast::Ident(s.to_string());

pub Num: ast::Num
    = r"-?[0-9]*"
    => ast::Num(isize::from_str(<>).unwrap());

pub AExp: ast::AExp = AExp_Add_Sub => <>;

AExp_Add_Sub: ast::AExp = {
    <f:AExp_Add_Sub> "+" <s:AExp_Mul_Div> =>
        ast::AExp::Add(Box::new(f),
                       Box::new(s)),
    <f:AExp_Add_Sub> "-" <s:AExp_Mul_Div> =>
        ast::AExp::Sub(Box::new(f),
                       Box::new(s)),
    AExp_Mul_Div => <>,
};

AExp_Mul_Div: ast::AExp = {
    <f: AExp_Mul_Div> "*" <s: AExp_Recur> =>
        ast::AExp::Mul(Box::new(f),
                       Box::new(s)),
    <f: AExp_Mul_Div> "/" <s: AExp_Recur> =>
        ast::AExp::Div(Box::new(f),
                       Box::new(s)),
    AExp_Recur => <>,
};

AExp_Recur: ast::AExp = {
    RVal_Non_Arith   => ast::AExp::Val(<>),
    "(" <e:AExp> ")" => e,
};

pub RVal: ast::RVal = {
    RVal_Non_Arith => <>,
    AExp           => ast::RVal::AExp(Box::new(<>)),
};

RVal_Non_Arith: ast::RVal = {
    FuncCall => ast::RVal::FuncCall(<>),
    Num      => ast::RVal::Num(<>),
    LVal     => ast::RVal::LVal(<>),
};

pub LVal: ast::LVal = {
    Ident => ast::LVal::Var(<>),
};

pub FuncCall: ast::FuncCall
    = <i: Ident> "(" <args: ParamList> ")"
    => ast::FuncCall { name: i, args: args };

pub ParamList: Vec<ast::RVal>
    = <v:(<RVal> ",")*> <e:RVal?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    };

pub FuncHead: ast::FuncHead
    = "fn" <name: Ident> "(" <params: ParamList> ")"
    => ast::FuncHead {
        name: name,
        params: params
    };
